El proyecto se basa en una arquitectura de capas pero sin la capa de persistencia. La primera capa que se ha implementado es la capa de presentación, esta capa tiene solo una clase llamada Controller. El controlador recibe las request del cliente y se conecta con la capa de negocio. 
Diferentes especificaciones de clase de controlador:
  - Esta clase tiene dos etiquetas de clase. @RestController (etiqueta de Spring) que se usa para identificar esta clase como un controlador que recibe la request y la etiqueta @Slf4j que se usa para poder utilizar logs (escribir en la consola).
  - El controlador solo tiene un método que aceptada request de tipo get.
  - Las etiquetas de esta metedo tiene diferente uso. Las etiquetas de @Operation y @ApiResponses se utilizan para proporcionar informacion al swagger. En cambio la etiqueta de @RequestMapping se utiliza para indicar la ruta a traves de la cual el usuario accede a nuestro servicio.
  - El metodo como entrada un unico campo que es un @PathVariable y este campo viene en la ruta ({productId}).
  - Por ultimo tenemos la llamada a una interfaz que se conecta con la capa de negocio. Para poder comunicarnos con esta interfaz necesitamos importarla utilizando la etiqueta @Autowired.

Cabe destacar que se utiliza interfaces para conseguir obtener desacoplamiento. A continuacion, tenemos la capa de negocio con las siguentes especificacione:
  - Lo primero se dispone de la etiqueta de @Service (etiqueta de Spring) que indica que la clase es un servicio.
  - Dentro de esta clase tenemos que importar la clase de RestTemplate para poder comunicarnos con otro servicio y tenemos 3 metodos donde 2 de ellos son privados y 1 publico.
  - El metodo publico se encarga de inicializar todas las variables necesarias para la implentacion del servicio y tambien, se encarga de realizar las llamadas a los metodos privados.
  - El metodo privado findProductDetail se encarga de obtener lo d-etalles de un producto a traves de un id proporcionado mediante una llamada rest de tipo get.
  - El metodo privado findSimiliarProductId se encarga de obtener una lista con los id de todos los productos que son similares al introducido por el cliente.
  - En los metodos privado se tiene un control de errores donde se lanza una excepcion en caso de algun problema.

Por ultimo tenemos un paquete de configuraciones donde se implementara el swagger:
  - El swagger se compone se de dos beans que se cargaran al ejecutar el servicio.
  - El primer bean se encarga de indicar donde se encuentra el controlador que se quiere exponer al cliente.
  - El segundo bean se añaden diferentes caracteristicas como el nombre del proyecto, version o un descripcion del servicio.
  
Y el paquete de configuracion tambien tiene una clase de configuracion del rest template:
  - En este caso se tiene una unica configuracion en la que se establece el tiempo maximo de espera y se inicia el rest template.
Tambien se tiene una clase en la que se inica el servicio a traves de un main (App.java).

La siguiente carpeta que nos centraremos ahora es la carpeta de src/resources:
  - En esta carpeta unicamente se dispone de un archivo (application-properties) en el que se especifica el endpoint al cual se hace la llamada rest y el puerto en el que se despliega el servcio.
  - Para acceder al valor del endpoint desde el nuestro servicio se necesita la etiqueta @Value

Por ultimo tenemos la carpeta de src/test donde se realizan los test de nuestro proyecto. Para poder realizar los test necesitamo la etiqueta de @SpringBootTest en todas las clases de test.
Test Servicio:
  - La primera clase que he testeado es la clase del servicio. Para poder testear se necesita importar la clase a testear con un @Autowired y en este caso ya que utiliza rest template se necesita mockear el bean (@MockBean). Esto se realiza debido a que no se quiere realizar la llamada real a otro servicio.
  - El primer test que se realiza es el funcionamiento correcto del metedo. Para ello se necesita indicar al servicio que tiene que devolver en la llamadas rest mediante los metodos when y then return. Despues se realiza la llamada a nuestro servicio y se comprueba que se han realizado las llamada de rest template.
Test Controlador:
  - Para este test necesitamos mockear la interfaz y importar webapplicationcontext y mockmvc para poder realizar las llamadas a nuestro servicio.
  - Ademas se necesita realziar un seteo antes de cada uno de los test que queremos realizar (BeforeEach).
  - Por ultimo se mockea la llamada a la interfaz indicando lo que tiene que devolver y se comprueba que se ha completado con exito la llamada al controlador.
Tambien se dispone de test adicionales para las clases que guardan informacion. Aunque estas clases solo tienen set y get y comprobacion de que los objetos son iguales.
